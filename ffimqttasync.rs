/* automatically generated by rust-bindgen */

pub type Persistence_open =
    ::std::option::Option<extern "C" fn(handle: *mut *mut ::libc::c_void,
                                        clientID: *const ::libc::c_char,
                                        serverURI: *const ::libc::c_char,
                                        context: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type Persistence_close =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type Persistence_put =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void,
                                        key: *mut ::libc::c_char,
                                        bufcount: ::libc::c_int,
                                        buffers: *mut *mut ::libc::c_char,
                                        buflens: *mut ::libc::c_int)
                              -> ::libc::c_int>;
pub type Persistence_get =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void,
                                        key: *mut ::libc::c_char,
                                        buffer: *mut *mut ::libc::c_char,
                                        buflen: *mut ::libc::c_int)
                              -> ::libc::c_int>;
pub type Persistence_remove =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void,
                                        key: *mut ::libc::c_char)
                              -> ::libc::c_int>;
pub type Persistence_keys =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void,
                                        keys: *mut *mut *mut ::libc::c_char,
                                        nkeys: *mut ::libc::c_int)
                              -> ::libc::c_int>;
pub type Persistence_clear =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type Persistence_containskey =
    ::std::option::Option<extern "C" fn(handle: *mut ::libc::c_void,
                                        key: *mut ::libc::c_char)
                              -> ::libc::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub context: *mut ::libc::c_void,
    pub popen: Persistence_open,
    pub pclose: Persistence_close,
    pub pput: Persistence_put,
    pub pget: Persistence_get,
    pub premove: Persistence_remove,
    pub pkeys: Persistence_keys,
    pub pclear: Persistence_clear,
    pub pcontainskey: Persistence_containskey,
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTClient_persistence = Struct_Unnamed1;
pub type MQTTAsync = *mut ::libc::c_void;
pub type MQTTAsync_token = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub payloadlen: ::libc::c_int,
    pub payload: *mut ::libc::c_void,
    pub qos: ::libc::c_int,
    pub retained: ::libc::c_int,
    pub dup: ::libc::c_int,
    pub msgid: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_message = Struct_Unnamed2;
pub type MQTTAsync_messageArrived =
    extern "C" fn(context: *mut ::libc::c_void,
                  topicName: *mut ::libc::c_char, topicLen: ::libc::c_int,
                  message: *mut MQTTAsync_message) -> ::libc::c_int;
pub type MQTTAsync_deliveryComplete =
    extern "C" fn(context: *mut ::libc::c_void, token: MQTTAsync_token) -> ();
pub type MQTTAsync_connectionLost =
    extern "C" fn(context: *mut ::libc::c_void, cause: *mut ::libc::c_char)
        -> ();
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub token: MQTTAsync_token,
    pub code: ::libc::c_int,
    pub message: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_failureData = Struct_Unnamed3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub token: MQTTAsync_token,
    pub alt: Union_Unnamed5,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed5 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed5 {
    pub unsafe fn qos(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn qosList(&mut self) -> *mut *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _pub(&mut self) -> *mut Struct_Unnamed6 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn connect(&mut self) -> *mut Struct_Unnamed7 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub message: MQTTAsync_message,
    pub destinationName: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub serverURI: *mut ::libc::c_char,
    pub MQTTVersion: ::libc::c_int,
    pub sessionPresent: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_successData = Struct_Unnamed4;
pub type MQTTAsync_onSuccess =
    extern "C" fn(context: *mut ::libc::c_void,
                  response: *mut MQTTAsync_successData) -> ();
pub type MQTTAsync_onFailure =
    extern "C" fn(context: *mut ::libc::c_void,
                  response: *mut MQTTAsync_failureData) -> ();
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub onSuccess: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub onFailure: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub context: *mut ::libc::c_void,
    pub token: MQTTAsync_token,
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_responseOptions = Struct_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub topicName: *const ::libc::c_char,
    pub message: *const ::libc::c_char,
    pub retained: ::libc::c_int,
    pub qos: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_willOptions = Struct_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub trustStore: *const ::libc::c_char,
    pub keyStore: *const ::libc::c_char,
    pub privateKey: *const ::libc::c_char,
    pub privateKeyPassword: *const ::libc::c_char,
    pub enabledCipherSuites: *const ::libc::c_char,
    pub enableServerCertAuth: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_SSLOptions = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub keepAliveInterval: ::libc::c_int,
    pub cleansession: ::libc::c_int,
    pub maxInflight: ::libc::c_int,
    pub will: *mut MQTTAsync_willOptions,
    pub username: *const ::libc::c_char,
    pub password: *const ::libc::c_char,
    pub connectTimeout: ::libc::c_int,
    pub retryInterval: ::libc::c_int,
    pub ssl: *mut MQTTAsync_SSLOptions,
    pub onSuccess: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub onFailure: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub context: *mut ::libc::c_void,
    pub serverURIcount: ::libc::c_int,
    pub serverURIs: *const *mut ::libc::c_char,
    pub MQTTVersion: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_connectOptions = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub struct_id: [::libc::c_char; 4usize],
    pub struct_version: ::libc::c_int,
    pub timeout: ::libc::c_int,
    pub onSuccess: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub onFailure: *mut ::std::option::Option<extern "C" fn() -> ()>,
    pub context: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_disconnectOptions = Struct_Unnamed12;
pub type Enum_MQTTASYNC_TRACE_LEVELS = ::libc::c_uint;
pub const MQTTASYNC_TRACE_MAXIMUM: ::libc::c_uint = 1;
pub const MQTTASYNC_TRACE_MEDIUM: ::libc::c_uint = 2;
pub const MQTTASYNC_TRACE_MINIMUM: ::libc::c_uint = 3;
pub const MQTTASYNC_TRACE_PROTOCOL: ::libc::c_uint = 4;
pub const MQTTASYNC_TRACE_ERROR: ::libc::c_uint = 5;
pub const MQTTASYNC_TRACE_SEVERE: ::libc::c_uint = 6;
pub const MQTTASYNC_TRACE_FATAL: ::libc::c_uint = 7;
pub type MQTTAsync_traceCallback =
    extern "C" fn(level: Enum_MQTTASYNC_TRACE_LEVELS,
                  message: *mut ::libc::c_char) -> ();
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub name: *const ::libc::c_char,
    pub value: *const ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MQTTAsync_nameValue = Struct_Unnamed13;
#[link(name = "paho-mqtt3a")]
extern "C" {
    pub fn MQTTAsync_setCallbacks(handle: MQTTAsync,
                                  context: *mut ::libc::c_void,
                                  cl:
                                      *mut ::std::option::Option<extern "C" fn(context: *const ::libc::c_void, cause: *const ::libc::c_char)
                                                                     -> ()>,
                                  ma:
                                      *mut ::std::option::Option<extern "C" fn(context: *const ::libc::c_void, topicName: *const ::libc::c_char, topicLen: ::libc::c_int, message: *const MQTTAsync_message)
                                                                     ->
                                                                         ::libc::c_int>,
                                  dc:
                                      *mut ::std::option::Option<extern "C" fn(context: *const ::libc::c_void, token: MQTTAsync_token)
                                                                     -> ()>)
     -> ::libc::c_int;
    pub fn MQTTAsync_create(handle: *mut MQTTAsync,
                            serverURI: *const ::libc::c_char,
                            clientId: *const ::libc::c_char,
                            persistence_type: ::libc::c_int,
                            persistence_context: *mut ::libc::c_void)
     -> ::libc::c_int;
    pub fn MQTTAsync_connect(handle: MQTTAsync,
                             options: *const MQTTAsync_connectOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_disconnect(handle: MQTTAsync,
                                options: *const MQTTAsync_disconnectOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_isConnected(handle: MQTTAsync) -> ::libc::c_int;
    pub fn MQTTAsync_subscribe(handle: MQTTAsync,
                               topic: *const ::libc::c_char,
                               qos: ::libc::c_int,
                               response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_subscribeMany(handle: MQTTAsync, count: ::libc::c_int,
                                   topic: *const *mut ::libc::c_char,
                                   qos: *mut ::libc::c_int,
                                   response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_unsubscribe(handle: MQTTAsync,
                                 topic: *const ::libc::c_char,
                                 response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_unsubscribeMany(handle: MQTTAsync, count: ::libc::c_int,
                                     topic: *const *mut ::libc::c_char,
                                     response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_send(handle: MQTTAsync,
                          destinationName: *const ::libc::c_char,
                          payloadlen: ::libc::c_int,
                          payload: *mut ::libc::c_void, qos: ::libc::c_int,
                          retained: ::libc::c_int,
                          response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_sendMessage(handle: MQTTAsync,
                                 destinationName: *const ::libc::c_char,
                                 msg: *const MQTTAsync_message,
                                 response: *mut MQTTAsync_responseOptions)
     -> ::libc::c_int;
    pub fn MQTTAsync_getPendingTokens(handle: MQTTAsync,
                                      tokens: *mut *mut MQTTAsync_token)
     -> ::libc::c_int;
    pub fn MQTTAsync_isComplete(handle: MQTTAsync, dt: MQTTAsync_token)
     -> ::libc::c_int;
    pub fn MQTTAsync_waitForCompletion(handle: MQTTAsync, dt: MQTTAsync_token,
                                       timeout: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn MQTTAsync_freeMessage(msg: *mut *mut MQTTAsync_message) -> ();
    pub fn MQTTAsync_free(ptr: *mut ::libc::c_void) -> ();
    pub fn MQTTAsync_destroy(handle: *mut MQTTAsync) -> ();
    pub fn MQTTAsync_setTraceLevel(level: Enum_MQTTASYNC_TRACE_LEVELS) -> ();
    pub fn MQTTAsync_setTraceCallback(callback:
                                          *mut ::std::option::Option<extern "C" fn()
                                                                         ->
                                                                             ()>)
     -> ();
    pub fn MQTTAsync_getVersionInfo() -> *mut MQTTAsync_nameValue;
}
